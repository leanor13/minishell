June 19:

-W flags are missing in makefile. We need to put them back before evaluation :)

0. clear cleans everything including prompt

1.
minishell$cat << $PWD
> d
> $PWD
d
minishell$echo $PWD

2.
echo "$PWD''"
this causes leaks!
minishell$echo "$PWD''"

minishell$echo $PWD
/home/yioffe/Projects/minishell
minishell$
exit
==2522985== Invalid free() / delete / delete[] / realloc()
==2522985==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==2522985==    by 0x40521D: free_env_lst (main_cleanup.c:47)
==2522985==    by 0x4053B5: free_shell (main_cleanup.c:93)
==2522985==    by 0x404680: main_parsing (main_parsing.c:148)
==2522985==    by 0x4041D9: main (main_minishell.c:23)
==2522985==  Address 0x4b2b740 is 0 bytes inside a block of size 32 free'd
==2522985==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==2522985==    by 0x405EFA: handle_dollar_sign (parser_joinlineutils_args.c:63)
==2522985==    by 0x405D4C: ft_strjoin_args (parser_joinlineutils_args.c:86)
==2522985==    by 0x406520: if_strjoin (parser_ifutils_2.c:20)
==2522985==    by 0x4050D2: ft_parser (parser.c:105)
==2522985==    by 0x4046BA: main_parsing (main_parsing.c:154)
==2522985==    by 0x4041D9: main (main_minishell.c:23)
==2522985==  Block was alloc'd at
==2522985==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==2522985==    by 0x4075F9: ft_strdup (ft_strdup.c:24)
==2522985==    by 0x403A32: add_back_env (env_helper.c:85)
==2522985==    by 0x403BC2: parse_env (env_helper.c:135)
==2522985==    by 0x40408A: handle_env (init.c:112)
==2522985==    by 0x404118: init_shell (init.c:127)
==2522985==    by 0x4041D0: main (main_minishell.c:22)
==2522985== 
==2522985== 

3. when running with no User (empty env):
==5005== 10 bytes in 1 blocks are definitely lost in loss record 8 of 79
==5005==    at 0x4885250: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-arm64-linux.so)
==5005==    by 0x10F643: ft_strdup (ft_strdup.c:24)
==5005==    by 0x10EDEF: add_var (ft_export_util.c:38)
==5005==    by 0x10B437: ft_export (ft_export.c:77)
==5005==    by 0x10BE6B: empty_user (init.c:84)
==5005==    by 0x10BFA7: handle_env (init.c:120)
==5005==    by 0x10BFDB: init_shell (init.c:127)
==5005==    by 0x10C09F: main (main_minishell.c:22)
==5005== 
==5005== LEAK SUMMARY:
==5005==    definitely lost: 10 bytes in 1 blocks
==5005==    indirectly lost: 0 bytes in 0 blocks
==5005==      possibly lost: 0 bytes in 0 blocks
==5005==    still reachable: 0 bytes in 0 blocks
==5005==         suppressed: 232,874 bytes in 238 blocks
==5005== 
==5005== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
==5005== 
==5005== 1 errors in context 1 of 2:
==5005== Conditional jump or move depends on uninitialised value(s)
==5005==    at 0x10ED38: add_var_free (ft_export_util.c:17)
==5005==    by 0x10EE9B: add_var (ft_export_util.c:53)
==5005==    by 0x10B437: ft_export (ft_export.c:77)
==5005==    by 0x10BE6B: empty_user (init.c:84)
==5005==    by 0x10BFA7: handle_env (init.c:120)
==5005==    by 0x10BFDB: init_shell (init.c:127)
==5005==    by 0x10C09F: main (main_minishell.c:22)
==5005==  Uninitialised value was created by a stack allocation
==5005==    at 0x10B360: ft_export (ft_export.c:63)
==5005== 

4. small: here it's probably "export", not "exit" :)
int	no_variable(char *equal_sign, t_export info)
{
...
			ft_putstr_nl("exit: not a valid identifier", STDERR_FILENO);
....
}

int	no_variable_novalue(char *var_name)
{
...
		ft_putstr_nl("exit: not a valid identifier", STDERR_FILENO);
...
}

5. export a=3
==6412== Conditional jump or move depends on uninitialised value(s)
==6412==    at 0x10ED38: add_var_free (ft_export_util.c:17)
==6412==    by 0x10EE9B: add_var (ft_export_util.c:53)
==6412==    by 0x10B437: ft_export (ft_export.c:77)
==6412==    by 0x10935F: exec_command (pipex.c:50)
==6412==    by 0x109527: execute_current_command (pipex.c:89)
==6412==    by 0x109617: process_commands (pipex.c:119)
==6412==    by 0x1096C7: exec_pipe (pipex.c:142)
==6412==    by 0x10EF27: executor_main (executor_main.c:28)
==6412==    by 0x10C5FF: main_parsing (main_parsing.c:160)
==6412==    by 0x10C0A7: main (main_minishell.c:23)
==6412==  Uninitialised value was created by a stack allocation
==6412==    at 0x10B360: ft_export (ft_export.c:63)
==6412== 
at least what I saw - var_value in add_var is not initialized if no equal sign. 
and probably some issue with int	add_var(int sign, char *equal_sign, t_shell *shell, t_export info) 
if the goal is to update info.sign, info has to be passed as pointer
also info.sign = add_var(info.sign, info.equal_sign, shell, info); - info.sign not initialized here, but is passed as argument 
here: no leak like that: git checkout dfb184d (see https://github.com/leanor13/minishell/commit/dfb184dea3a3cafcce81ea29af5b8a9b77487c12)

6. int	ft_export(t_shell *shell, t_arg *command)
{
	t_export	info;

	info.i = 1;
	info.args = command->arguments;
	if (no_export(shell, info.args))
		return (EXIT_SUCCESS);
	while (info.args[info.i] != NULL) 
	{
		info.equal_sign = strchr(info.args[info.i], '=');
	
	NEED TO CHANGE strchr to ft_strchr!!!
	also in parse_env! 		equal = strchr(env_copy, '=');

7. minishell$cat << k | << s
minishell: syntax error near unexpected token `<<'


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
echo a'<'
bash: syntax error: unclosed quote
minishell$echo a'l'

main parsing I did not put dup2 into another function it is more than 25 lines now
touch something >> out3 | cat
echo "valami" | echo "" || make valgrind

w

export ""
export ''
export $USER - it opens
export $okay=something - in bash this gives error

"$USER'''" this one maybe a changin on find_var

return(EXIT_FAILURE)

- SIGNALS - will do in the end. Don't forget to add signals to here_doc as well
- (YULIA?) (minor) export should print alphabetically. We can do it if we want.
- (TINA) cat Makefile > out1.txt >> out2.txt: if we do both > and >> redirections, we always do what command->append says. What we can do: not sure... maybe have few lists files_to_append and files_to_rewrite. And put the flag whichever is last.
- (YULIA) HEREDOC: once SIGNALS done - add signals there
- (minor) SHLVL parameter when calling ./minishell

- (TINA?) (minor) cat << f <<
expected behavior
> f
bash: syntax error near unexpected token `newline'

TAB: ctrl-v + TAB

testers help:
2. https://github.com/MariaAguiar/minitester
3. check all buildins to make sure 1st argument is taken
4. https://docs.google.com/spreadsheets/d/17linwSWODYO4O9Db0FohJYr_8shMTGvyo0MjToPrcAI/edit#gid=1305472556
5. check empty and corrupted env


To open VS Code in a Docker container:

Click on the green icon in the lower-left corner of the status bar (or use the command palette F1 and search for "Remote-Containers: Open Folder in Container...").
Select the folder you want to open in the container.
VS Code will reload and open the folder inside the Docker container.
To switch back to running VS Code on your local machine:

Click on the green icon in the lower-left corner of the status bar (or use the command palette F1 and search for "Remote-Containers: Reopen Locally").
VS Code will reload and open the folder on your local machine.
Remember, you need to have Docker installed and running on your machine to use the "Remote - Containers" extension. If you don't have the extension installed, you can install it from the Extensions view (Ctrl+Shift+X).
