

Notes (29.05) while checking on 42evals:
1. Checking the exit status, sometimes -1 instead of 1, export spaces, export "" ? $ with special symbols
thuy-ngu@c1r9s1:~/minishellfinal$ echo "okay
> 
bash: unexpected EOF while looking for matching `"'
bash: syntax error: unexpected end of file
thuy-ngu@c1r9s1:~/minishellfinal$ echo $?


Notes (3.06):
1. need to fix this - when shell is empty
==4100== Use of uninitialised value of size 8
==4100==    at 0x10B540: ft_export (ft_export.c:70)
==4100==    by 0x10C43F: empty_user (init.c:84)
==4100==    by 0x10C57B: handle_env (init.c:120)
==4100==    by 0x10C5A7: init_shell (init.c:126)
==4100==    by 0x10C673: main (main_minishell.c:22)
==4100==  Uninitialised value was created by a stack allocation
==4100==    at 0x10C618: main (main_minishell.c:14)
==4100== 
==4100== 
==4100== 1 errors in context 2 of 6:
==4100== Use of uninitialised value of size 8
==4100==    at 0x10B52C: ft_export (ft_export.c:70)
==4100==    by 0x10C43F: empty_user (init.c:84)
==4100==    by 0x10C57B: handle_env (init.c:120)
==4100==    by 0x10C5A7: init_shell (init.c:126)
==4100==    by 0x10C673: main (main_minishell.c:22)
==4100==  Uninitialised value was created by a stack allocation
==4100==    at 0x10C618: main (main_minishell.c:14)
==4100== 

2. Need to investigate. it's some malloc that is used and not freed
==4100== 2 bytes in 1 blocks are definitely lost in loss record 2 of 89
==4100==    at 0x4885250: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-arm64-linux.so)
==4100==    by 0x10F01F: ft_itoa (ft_itoa.c:67)
==4100==    by 0x10E3C3: ft_strjoinline_args (parser_joinlineutils_args.c:63)
==4100==    by 0x10D7BB: ft_parser (parser.c:184)
==4100==    by 0x10C7EB: main_parsing (main_parsing.c:83)
==4100==    by 0x10C67B: main (main_minishell.c:23)
==4100== 
==4100== 2 bytes in 1 blocks are definitely lost in loss record 3 of 89
==4100==    at 0x4885250: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-arm64-linux.so)
==4100==    by 0x10EF9B: ft_itoa (ft_itoa.c:67)
==4100==    by 0x10E3C3: ft_strjoinline_args (parser_joinlineutils_args.c:63)
==4100==    by 0x10D7BB: ft_parser (parser.c:184)
==4100==    by 0x10C7EB: main_parsing (main_parsing.c:83)
==4100==    by 0x10C67B: main (main_minishell.c:23)
==4100== 
==4100== 4 bytes in 2 blocks are definitely lost in loss record 5 of 89
==4100==    at 0x4885250: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-arm64-linux.so)
==4100==    by 0x10E9F3: ft_strdup (ft_strdup.c:24)
==4100==    by 0x10E3E7: ft_strjoinline_args (parser_joinlineutils_args.c:65)
==4100==    by 0x10D7BB: ft_parser (parser.c:184)
==4100==    by 0x10C7EB: main_parsing (main_parsing.c:83)
==4100==    by 0x10C67B: main (main_minishell.c:23)

3. 

MEMORY leaks tests:
1. echo
2. cat Makefile > out | awk '{print $1}'
3. empty env + not-empty env but no USER
4. check open fds for children

echo '$USERkoevkfvpojrvs'

return(EXIT_FAILURE)

1. OK Pressing tab few times shows all files - ASK FOR EXPLANATION
2. (need to implement) Execute a simple command with an absolute path like /bin/ls, or any other command with arguments but without any quotes and double quotes. Then execute echo $?
handle $, echo $?, expr $? + $?
Notes: - PARSER: can take *shell as an input. And $? should be shell->exit_status.
      -  PARSER: It would be good if PARSER also can write list right into shell->args_list.
      - EXECUTOR: make sure to write all needed exit statuses to shell->exit_status. Check builtins and cases when no path etc.
For export return error status for {export name = dmkdm}
3. Signals - will do in the end. Don't forget to add signals to here_doc as well
4. PARSER: echo '$USER' - EXPECTED: $USER. NOW it prints content of $USER with ' in the end. echo '"$USER"' should print "$USER", echo "$USER" should print username, now both work good.
5. PARSER: We need to run more tests for single quotes. Also for '$?', some flags etc.
6. (YULIA?) (minor) export should print alphabetically. We can do it if we want.
7. (done YULIA) cd and pwd not yet tested. (for pwd testing we need cd). When cd is done, check how it works with empty env (env -i ./minishell)
8. (TINA) export (only need to fix update and case with spaces)
9. (minor) if we do both > and >> redirections, we always do what command->append says. What we can do: not sure... maybe have few lists files_to_append and files_to_rewrite. And put the flag whichever is last.
9. (TINA?)(minor) export $okay=something - in bash this gives error
10. (YULIA) remove all TODO
11. (TINA) ask seombody what it means on EVALUATION SHEET: Check if multiple tries of the same redirections fail.
12. (YULIA) HEREDOC: once SIGNALS done - add signals there
13. (Done - YULIA) ./minishell
14. (TINA?) (minor) cat << f <<
expected behavior
> f
bash: syntax error near unexpected token `newline'
15. Memory leaks
16. (TINA) export without value (like {export r}) creates duplicates
17. (YULIA) failed builtins don't give $? = 1, they return 0



testers help:
2. https://github.com/MariaAguiar/minitester
3. check all buildins to make sure 1st argument is taken
4. https://docs.google.com/spreadsheets/d/17linwSWODYO4O9Db0FohJYr_8shMTGvyo0MjToPrcAI/edit#gid=1305472556
5. check empty and corrupted env


To open VS Code in a Docker container:

Click on the green icon in the lower-left corner of the status bar (or use the command palette F1 and search for "Remote-Containers: Open Folder in Container...").
Select the folder you want to open in the container.
VS Code will reload and open the folder inside the Docker container.
To switch back to running VS Code on your local machine:

Click on the green icon in the lower-left corner of the status bar (or use the command palette F1 and search for "Remote-Containers: Reopen Locally").
VS Code will reload and open the folder on your local machine.
Remember, you need to have Docker installed and running on your machine to use the "Remote - Containers" extension. If you don't have the extension installed, you can install it from the Extensions view (Ctrl+Shift+X).